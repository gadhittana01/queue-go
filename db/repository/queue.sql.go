// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queue.sql

package querier

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createQueue = `-- name: CreateQueue :one
INSERT INTO "queue"(queue_number, user_id, arrival_time) VALUES
($1, $2, $3) RETURNING id, queue_number, user_id, arrival_time, service_time, total_waiting_time, created_at, updated_at
`

type CreateQueueParams struct {
	QueueNumber string    `json:"queue_number"`
	UserID      uuid.UUID `json:"user_id"`
	ArrivalTime time.Time `json:"arrival_time"`
}

func (q *Queries) CreateQueue(ctx context.Context, arg CreateQueueParams) (Queue, error) {
	row := q.db.QueryRow(ctx, createQueue, arg.QueueNumber, arg.UserID, arg.ArrivalTime)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.QueueNumber,
		&i.UserID,
		&i.ArrivalTime,
		&i.ServiceTime,
		&i.TotalWaitingTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteQueue = `-- name: DeleteQueue :exec
DELETE FROM "queue" WHERE id=$1 AND user_id=$2
`

type DeleteQueueParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteQueue(ctx context.Context, arg DeleteQueueParams) error {
	_, err := q.db.Exec(ctx, deleteQueue, arg.ID, arg.UserID)
	return err
}

const findLatestQueue = `-- name: FindLatestQueue :one
SELECT id, queue_number, user_id, arrival_time, service_time, total_waiting_time, created_at, updated_at FROM "queue"
ORDER BY created_at DESC
LIMIT 1 FOR UPDATE NOWAIT
`

func (q *Queries) FindLatestQueue(ctx context.Context) (Queue, error) {
	row := q.db.QueryRow(ctx, findLatestQueue)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.QueueNumber,
		&i.UserID,
		&i.ArrivalTime,
		&i.ServiceTime,
		&i.TotalWaitingTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findQueue = `-- name: FindQueue :many
SELECT id, queue_number, user_id, arrival_time, service_time, total_waiting_time, created_at, updated_at FROM "queue"
`

func (q *Queries) FindQueue(ctx context.Context) ([]Queue, error) {
	rows, err := q.db.Query(ctx, findQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Queue{}
	for rows.Next() {
		var i Queue
		if err := rows.Scan(
			&i.ID,
			&i.QueueNumber,
			&i.UserID,
			&i.ArrivalTime,
			&i.ServiceTime,
			&i.TotalWaitingTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findQueueByID = `-- name: FindQueueByID :one
SELECT id, queue_number, user_id, arrival_time, service_time, total_waiting_time, created_at, updated_at FROM "queue" WHERE id=$1 AND user_id=$2
LIMIT 1 FOR UPDATE
`

type FindQueueByIDParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) FindQueueByID(ctx context.Context, arg FindQueueByIDParams) (Queue, error) {
	row := q.db.QueryRow(ctx, findQueueByID, arg.ID, arg.UserID)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.QueueNumber,
		&i.UserID,
		&i.ArrivalTime,
		&i.ServiceTime,
		&i.TotalWaitingTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateQueue = `-- name: UpdateQueue :one
UPDATE "queue"
SET service_time=$2,
total_waiting_time=$3
WHERE id=$1 RETURNING id, queue_number, user_id, arrival_time, service_time, total_waiting_time, created_at, updated_at
`

type UpdateQueueParams struct {
	ID               uuid.UUID       `json:"id"`
	ServiceTime      sql.NullTime    `json:"service_time"`
	TotalWaitingTime pgtype.Interval `json:"total_waiting_time"`
}

func (q *Queries) UpdateQueue(ctx context.Context, arg UpdateQueueParams) (Queue, error) {
	row := q.db.QueryRow(ctx, updateQueue, arg.ID, arg.ServiceTime, arg.TotalWaitingTime)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.QueueNumber,
		&i.UserID,
		&i.ArrivalTime,
		&i.ServiceTime,
		&i.TotalWaitingTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
